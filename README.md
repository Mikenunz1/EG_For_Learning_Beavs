# **CS 362 \- Group 16 \- Living Document**

# **Project Proposal**

## **Section 1: Team Info**

| Name | Role | Responsibilities |
| :---- | :---- | :---- |
| Grant Pasquantonio | Sound Designer / Data Flow Manager | Sound Design Music Design Sound Object implementation Data Modeling |
| Jacob MacGregor | Lead Artist | Character Design Pixel Art Asset Management  |
| [Guillermo Morales](mailto:gmoral34@my.chemeketa.edu) | Network Designer | Multiplayer Research Lead multiplayer Programmer Networking and HTTP requests General Game Programmer  |
| Mike Nunzio | Head Developer | Class Hierarchy Object Design Scene management File Systems UI/UX design  |
| Ryan Shepard | Lead Content Researcher | Research Documentation Sourcing of Educational content Test Design Quality Assurance |
| Mia Matsunaga | Lead Environmental Designer | Level Design Environmental Design Interior Environment Design Secondary Scene management |

## 

**Link to git repo:** [https://github.com/Mikenunz1/EG\_For\_Learning\_Beavs](https://github.com/Mikenunz1/EG_For_Learning_Beavs)  
**Link to Trello:** [https://trello.com/invite/b/6784b145017449ebb57445d5/ATTIf7160beff227933ea292ae84884288a9EE3A5DEA/pt16-the-educational-game-for-learning-beavers](https://trello.com/invite/b/6784b145017449ebb57445d5/ATTIf7160beff227933ea292ae84884288a9EE3A5DEA/pt16-the-educational-game-for-learning-beavers) 

**Link to Living Document:** [https://docs.google.com/document/d/1eOyTp74D\_NZpjCQp7QcDlS1iRPAxO5V3PQBEi2p0Fsk/edit?usp=sharing](https://docs.google.com/document/d/1eOyTp74D_NZpjCQp7QcDlS1iRPAxO5V3PQBEi2p0Fsk/edit?usp=sharing)

**Primary Communication Channel:** Discord  
**Secondary Communication Channel:** Email  
**Communication rules:**

* Respond to email communication within 16 hours.  
* Expected response time frame for written communication: 8am–6pm   
* Be respectful of every team member’s ideas and their various skills and experience levels.  
* Complete assignments at least 24 hours before the due date so that we have time to adapt as necessary.    
* Communicate ASAP if you are unable to complete your portion of the assignment by the due date so that the rest of the team may adjust.  

# 

# **Section 2: Product Description**

* **Project Title**: Educational Game for Learning Beavers\!  
* **Abstract**: The Educational Game for Learning Beavers is an interactive project designed to teach players about beavers and their habitats through gameplay. Unlike traditional methods like reading or watching videos, this game aims to reach a broader audience, even those who may not already be interested in beavers. Built with the Godot game engine and using GitHub for teamwork, the game will include key features such as save/load options, inventory, player movement, sound effects and educational content. If time allows, we will also add multiplayer gameplay and NPCs that adapt to player actions. This project’s goal is to make learning about wildlife ecosystems both fun and educational.   
* **Goal:** Our project will create an educational game which seeks to teach the user/player about beavers through game mechanics, story, and flavor text. This will not only be about entertaining the player but also sourced, educational content through playing the game. The game will follow similar principles to games made by companies like Brainpop and Leapfrog. We’d be developing this game for a general audience, potentially mimicking the style of edutainment games we grew up with, but with a heavier focus on game content. 

* **Current Practice:** The traditional way educational content is taught is through reading, videos or other classes. This is limited in that it normally only teaches those who already have interest in the subject.  
* **Novelty:** Compared to traditional education content, our game would reach people beyond the normal audience who would want to learn about beavers. The game is geared to be entertaining without the educational content, so someone may play the game for fun and end up becoming interested in learning more about beavers and the environment.  
* **Effects:** Give users an informative and entertaining way to understand more about the pond/river/stream wildlife ecosystem.  
* **Technical Approach**: We will use the Godot game engine for the majority of this project.  We will use GitHub as our version control system.  Sound design and music creation will be done using FL Studio as a Digital Audio Workstation.  Pixel  
* **Risks:**  Many of us are completely new to Godot and game development in its entirety.  To be successful, we will need to adequately learn both the software and the discipline.  To mitigate this risk, our experienced members will help the less experienced members.  Furthermore, they will include resources (online teaching for the tools we will be using) to ensure everyone is ready.  


# **Section 3: Major Feature Implementation (4+)**

* Save/Load  
* Music/Sound Design  
* Player Movement  
* Player Inventory  
* Educational content about beavers

# **Section 4: Stretch Goals (2+)**

* Multiplayer   
* Dynamic NPC (non-playable character) AI that remembers player actions and changes its responses accordingly

# 

# 

# 

# 

# 

# 

# 

# 

# 

# 

# **Project Requirements Elicitation**

# **Section 1: Use Cases (1+ Each)**

**Ryan’s Use Case:** 

1. Actors: A person who plays video games  
2. Triggers: They see our game and think it looks fun, so they download it  
3. Preconditions: The user thinks our game looks more fun than the alternatives.   
4. Postconditions (success scenario): They are entertained and have some understanding of beavers.   
5. List of steps (success scenario): They begin playing the game. They understand what to do, and keep playing the game. They complete the main story of the game.  
6. Extensions/variations of the success scenario: As they are playing the game, they become more interested in Beavers. They read more dialogue and information within the game about Beavers as they play. The game encourages them to look at additional resources about beavers and how they contribute to the environment.  
7. Exceptions: failure conditions and scenarios: They decide the game is not fun and they stop playing. The game crashes and they decide not to try again. 

**Grant’s Use Case:**

1. Actor: Educator  
2. Triggers: The educator finds the game while searching for Pacific Northwest educational materials.    
3. Preconditions: The educator needs to explain to their students how beavers are ecological engineers in a way that interests the students.  
4. Post-conditions: The students will understand and retain important information about beavers.    
5. List of steps:   
   1. Student / educator installs the game on to the appropriate machine.  
   2. Student experiences educational content infused with game mechanics.  
   3. Student reads educational content written in NPC dialogue and flavor text.  
   4. Student plays through the entirety of the game and maintains interest in the educational content.  
6. Extensions / variations of the success scenario:   
   1. Students are inspired by the game to do further research.  
   2. Alternatively, the multiplayer aspect of the game could be the driving force for interest in the educational content about beavers.  
7. Exceptions: failure conditions and scenarios:  
   1. Students do not successfully install the game.   
   2. Students get distracted by non-educational features and therefore do not retain the educational content. 

**Mia’s Use Case:**

1. Actor: A person interested in learning about beavers  
2. Triggers: The person is doing research on the internet about beavers and finds the Educational Game for Learning Beavers.  
3. Preconditions: The user reads the game description and finds that the game will teach them valid educational content about beavers.   
4. Post-conditions: The user has fun playing the game and learns a lot of useful information about beavers.  
5. List of steps:   
   1. The user reads the description of the game.  
   2. The user installs the game.  
   3. The user plays the game and learns information about beavers and their environment.  
   4. The user plays through the entirety of the game.  
6. Extensions/variations of the success scenario:   
   1. The user enjoys their learning experience and shares the game with their friends.   
7. Exceptions: failure conditions and scenarios:   
   1. The user isn’t sure if the game teaches valid information, and doesn’t install the game.  
   2. The user doesn’t feel like they are learning the information they are looking for, so they stop playing the game.

**Guillermo’s Use Case**

1. Actor: Parent/Guardian   
2. Triggers:  Parent/Guardian wants to provide feedback on my child's experience with the game, so that developers can improve the game to better meet educational needs and enhance user experience.  
3. Preconditions: The game is installed on the actor’s or child’s computer.  
4. Post-conditions: The parent successfully submits their feedback through the designated mechanism  
5. List of steps:  
   1. The parent decides to provide feedback  
   2. The parent navigates to the game’s main menu or settings and selects the "Provide Feedback" option.  
   3. The parent selects the type of feedback they wish to provide (e.g., bug report, feature suggestion, content improvement).  
   4. The parent clicks the "Submit" button to send their feedback to the developers.  
   5. The game displays a confirmation message thanking the parent for their feedback.  
   6. The development team accesses the submitted feedback through their internal tracking system.  
   7. Update may be communicated in future game updates  
6. Extensions/variations of the success scenario: Parents have the choice to submit feedback anonymously, promoting honesty without concerns about privacy.  
7. Exceptions: failure conditions and scenarios: The feedback form fails to load, or the submission process encounters errors.

‘

**Mike’s Use Case**

1. Actor: Programmer interested in Godot as an engine  
2. Triggers: A programmer who has never used Godot before is looking to try out an engine. They decide to explore games made with the Godot engine, such as ours.  
3. Preconditions: The precondition in this case would be that the user is a programmer who is interested in game programming but has NEVER worked in Godot.   
4. Post-conditions: The programmer now has as a frame of reference for what kind of 2D games you can make in Godot. For example, the programmer knows that you can program 2D movement, menu navigation, inventory, etc.  
5. List of steps:	Programmer has interest in Godot Game development. They search for games available online made with the Godot engine. The programmer finds and downloads the game. The programmer runs the game and takes notes of the different features we implemented. The user eventually exits the game and takes what they have learned and applies it to projects of their own.   
6. Extensions/variations of the success scenario: While playing our game they read about some of the tools external to Godot that we used for production and decide to research those as well, further expanding their game development knowledge.   
7. Exceptions: failure conditions and scenarios: The user fails to find our game while searching for games to learn about Godot, and then has a bad experience with another game they studied.

**Jacob’s Use Case**

1. Actor: A Museum  
2. Triggers: A museum is interested in enhancing their ecological exhibit and finds the game while doing research.  
3. Preconditions: They could provide a screen with the game running in an existing environment as an addition to a beaver or wildlife display.  
4. Postconditions: People visiting the museum could play the game and interact with the exhibit while at the display  
5. List of steps: User approaches the exhibit and plays the game   
6. Extensions: A successful interaction with the exhibit leaves the museum attendee with more knowledge of beavers and a positive experience.  
7. Exceptions: failure conditions and scenarios: The game is left in an open state and someone approaching it enters in the middle of the experience 

# 

# 

# 

# 

# 

# 

# 

# 

# 

# 

# 

# 

# **Section 2: Non-functional Requirements**

* **Usability:** The controls will follow expected standards, such as W-A-S-D for movement so that the game feels familiar to users. The GUI will be simple so that it clearly displays any relevant information to the user.   
* **Performance:** The game should produce at least 30 frames per second on machines with the minimum specifications.   
* **Scalability:** The multiplier function should maintain optimal performance and reliability as the user base grows, ensuring scalability

# 

# **Section 3: External Requirements**

* **Reliability:** The game should achieve reliability by avoiding any crashes, regardless of user input.  If a player attempts to exit the map or otherwise generate unexpected behavior, there should be sufficient countermeasures to prevent them.   
* **Accessibility:** We can upload the final game to itch.io or a similar indie game service in order to let people install the game easily. If a user wanted to build our game from source, they could download a version from our Repo and use the Godot engine to build and run a programmable version on their machine. Lastly, we plan to build the game with different accessibility features in mind such as alternative controller support, resizable text, and proper text contrast  
* **Scope:** The scope of this game is scalable because we can adjust the length of the game easily.  If it seems like the group is progressing too slowly to meet our initial plans, we are capable of culling certain game elements so that it can be completed within the time frame.  If it seems that we are progressing too quickly, the style of the game allows us to add additional features

# 

# 

# 

# **Project Architecture and Design**

## **Section 1: Software Architecture**

### **Major Software Components:**

* **Game Manager**: The game manager will be a centralized object that loads in first before anything else within the game. It will be responsible for variables, methods, and objects that are important to keep track of independently of which scene the player is in. It’s also used to manage game systems such as file saving and loading, player location, scene management, etc.  
  * **Interfaces**: Traversable map, inventory, minigames, NPCs, Objects, All UI systems,   
  * **Data**: Player save file, NPC save files, in game time, inventory objects, story process, player location data, NPC movement, scene management data  
  * **Assumptions**: Assumes that each individual component has methods to communicate data back to game manager and methods to receive data from game manager  
* **Ingame Player Object**: The in-game player object refers to the CharacterBody2D which is moved in game by the player in order to traverse and interact with the game world. When a player gives input data such as keyboard inputs, the game responds accordingly by moving and acting on the player object.   
  * **Interfaces**: Game manager, traversable map, inventory, interactable NPC’s, minigames, interactable objects  
  * **Data**: Player x coordinate, player y coordinate, speed, 2Dsprite, Area2D, CollisionShape  
  * **Assumptions**:  
* **Interactable NPCs**:   
  * **Interfaces**: Player Object, Game Manager, Traversable Map, Inventory  
  * **Data**: Dialogue, objectives / quest information, sprites, and movement scheduling pattern.  
  * **Assumptions**: Assumes that the NPC will be spawned as an instance in a Traversable Map instance.    
* **Interactable Objects**: These are the objects in game that the player can move or collect to place in their inventory  
  * **Interfaces**: Player Object, Game Manager, Inventory  
  * **Data:** Type of object, position coordinates, and properties.  
  * **Assumptions**: The player is close enough to the object to interact with it and that it will respond to player input.  
* **Traversable Map**: The traversable map allows players to explore a realistic beaver environment using their keyboard keys to move. Players can navigate to various locations where they can interact with NPCs, objects, and engage in minigames. The map may change based on the player’s progress in the game.  
  * **Interfaces**: Game Manager, Player Object, Interactable NPCs, Interactable Objects  
  * **Data**: Tile assets and their coordinates. References some data found in game manager, including player coordinates, object coordinates, and NPC coordinates.  
  * **Assumptions**: Assumes that the game manager has saved the player’s progress and the state of the map. Based on the player’s coordinates, certain objects, NPCs, or minigames will become available and interactable.   
* **Inventory**:   
  * **Interfaces**: Player Object, Gamer Manager, Settings Menu  
  * **Data**: Items, Item Sprites  
  * **Assumptions**: It assumes that the Game Manager will load item data into the inventory upon loading a save.  Likewise, saving a game should send item data to the Game Manager so that it can be written to a file.    
* **Main Menu UI**: This is the first menu that the player interacts with upon loading the game. It provides options on if they want to start a new game, load a game, play multiplayer, switch game settings, and quit the game.   
  * **Interfaces**: Game Manager, Settings UI, Multiplayer UI  
  * **Data**: Does not hold any data in itself, only references data found in the game manager. The menu makes calls to the game Manager which then performs functions on game data  
  * **Assumptions**: Assumes that the game manager properly loads the main menu on game startup.   
* **Ingame UI**: The ingame UI displays important information regarding the player’s progress in the game, including inventory and the map. The ingame UI also includes a menu that allows players to pause, exit, or access the settings of the game.  
  * **Interfaces**: Game Manager, Player Object, Traversable Map, Minigames, Inventory, Settings  
  * **Data**: References data found in the game manager, including player progress, player coordinates, etc.  
  * **Assumptions**: Assumes that the game manager properly loads the player’s game and progress.   
* **Settings Menu**: The settings menu will allow the player to adjust screen resolution, audio levels, and text size.  
  * **Interfaces:** Game Manager, Main Menu UI   
  * **Data**: References the values stored in the Game Manager for audio tracks, resolution and text size.  
  * **Assumptions**: The game manager properly loads and saves audio track, screen resolution, and text size values.  
* **Online Multiplayer Mode**:   
  * **Interfaces**: Game Manager, Main Menu, Multiplayer system (for starting or joining multiplayer sessions)  
  * **Data**:  
    * Multiplayer session information   
    * Player settings related to multiplayer (like player name, character customization, etc.).  
  * **Assumptions**:  
    * Assumes the multiplayer system is connected to the main menu, allowing players to select or join multiplayer games.  
    * Assumes the multiplayer system will be stable and able to manage matchmaking or session creation.  
    * Assumes the game handles synchronization of multiplayer data, such as player positions, inventory, and interactions.  
    * Assumes players have internet connectivity when trying to join an online session.

* **Dam Building Minigame**:   
  * **Interfaces**: Game Manager, Player Object, Ingame UI  
  * **Data**:  
    * Player progress  
    * Object placement (e.g., position of logs, rocks, or other building materials).  
    * Minigame time (e.g., countdown timer)  
  * **Assumptions**:  
    * Assumes that the player can interact with objects in the environment to collect materials for the dam.  
    * Assumes the game properly tracks the player’s progress in the minigame and rewards successful dam building with in-game rewards or story progression.  
    * Assumes there will be a clear win/lose condition (e.g., completing the dam or running out of time).  
    * Assumes the player can pause or quit the minigame at any time, returning to the main game.  
        
* **Swimming Minigame**: This will be a side-scrolling swimming game where the beaver has to dodge objects and NPCs to navigate through the river to bring sticks to his dam.  
  * **Interfaces**: Player Object, Game Manager, NPCs  
  * **Data**: Player position coordinates. Obstacle and NPC positions. Progress made towards the goal.  
  * **Assumptions**: Player chooses to enter the minigame. Minigame is over when the player has too many collisions, or reaches the goal.

* **Tree Cutting Minigame**: Players will be tasked with cutting down a tree for their dam. They will need to follow the correct shape to effectively chop down the tree. This minigame is intended to educate players on how beavers use their teeth to cut down trees.   
  * **Interfaces**: Game manager, inventory, traversable map  
  * **Data**: Player positions (x and y coordinates), player’s progress towards cutting down the tree   
  * **Assumptions**: Assumes the player has navigated to the forest and has decided to engage with the minigame through some mechanism. The minigame will end once the player successfully cuts the tree down or chooses to exit the game.   
      
* **Communication Minigame**: In this minigame the player will watch the beaver perform a sequence of audio and visual cues that will then need to be reproduced through pressing the corresponding buttons in the correct order.  
  * **Interfaces**: Player Object, Game Manager  
  * **Data**: Sounds, character animations, buttons corresponding to each sound and animation  
  * **Assumptions**: The player will see the button on the screen with each animation or sound that they will need to reproduce

* **Canal Puzzle/Minigame**: This is a minigame scene that will involve the player creating a canal from a water source to a goal location.  It will be mazelike, so there will be objects preventing a direct path.  Once the player completes the minigame, there will be a reward added to the Inventory.  
  * **Interfaces**: Game Manager, Player Object, Interactable Object, Inventory  
  * **Data**: Child instances of Player Object, Interactable Object, Music File, SFX particular to the minigame  
  * **Assumptions**: Assumes that the player has fulfilled the pre-conditions to access this minigame.


* **Feedback UI**:   
  * **Interfaces**: Main Menu UI, Game Manager  
  * **Data**: Feedback data from users (e.g., bug reports, suggestions, comments).  
  * **Assumptions**:  
    * Assumes that the game has a functioning feedback form within the UI.  
    * Assumes the player can access the feedback UI from the game’s menu or settings screen.  
    * Assumes the game can send feedback to a server.  
    * Assumes the player will be prompted to submit feedback after completing specific game segments, such as the end of a level or after encountering a bug.

### **Decision Alternatives:**

**Static Traversable Map**

* **Pros**:   
  * Simpler to implement, as the map doesn't change dynamically.   
    * Easier to test and debug.  
  * **Cons**:   
    * Limits replayability, as players cannot explore new areas or experience the environment changing based on their progress.

**Local Multiplayer Mode**

* **Pros**:   
  * No internet access required   
    * Easier to test and debug.  
    * Lower latency  
  * **Cons**:   
    * Not ideal for situations where players cannot easily sit around the same screen, like at a large event or for remote play  
    * Games with split-screen or shared screen need to be carefully designed to ensure that everyone can see and interact with the game properly.

## **Section 2: Software Design**

* **Game Manager**: The game manager will be a 2D node scene. It’s the highest level of abstraction, taking care of higher order functions, variables, and components of the game. It will be responsible for keeping track of data that’s independent of specific scenes, and used to load and unload different scenes/instances. 

* **Ingame Player Object**: The player object will be a Characterbody2D node with an animated 2D sprite, an Area2D and some collision boxes. It will be part of a few classes, including “Pauseable” which covers objects that may be paused, and “GameComponents” which covers objects and classes that send data to the game manager 

* I**nteractable NPCs**: Interactable NPCs are responsible for moving around the Traversable Map, delivering dialogue to the player, and playing certain sounds.   
  * 2D Area: Detect if the Player Object is within a radius around the NPC.  
  * 2D Collision Shape: Use physics engine to prevent the player from entering the NPC hit-box.  It will also prevent the NPC from entering non-permitted areas.   
  * Animated Sprite: Display actions the NPC is taking. For example, this could be idle, move left, move right, move down, move up, talk, etc.   
  * Label: Indicate that the player is close enough to interact with the NPC using a short text label.  
  * AudioStreamPlayer2D: Play NPC specific SFX.

* **Interactable Objects:** Interactable Objects will be 2D sprites, have an Area2D, collision boxes, and ObjectProperties. Depending on the type of object it will have different ObjectProperties that will dictate which type it is and whether or not the player can add it to their inventory. The sprites will vary in size and Area2D which will affect the size of their collision box.

* **Traversable Map:** The traversable map will be created using TileMaps in Godot, which uses a grid of tiles to form the layout of the game. The map will include 2D areas, so objects, NPCs, and minigames are triggered or accessible when they enter certain areas. 2D Collision Shape will also be used to define boundaries on the map and prevent players from passing through solid objects.

* **Inventory:**  This structure represents a player’s inventory which can hold items.    
  * Inventory\_ui: This is a control node responsible for managing the player’s items.   
    * AudioStreamPlayer: This will be responsible for playing inventory UI sound effects.  
    * Grid Container: The part of the UI which visually organizes the inventory\_ui\_slots into a grid pattern.  
      * Inventory\_ui\_slot: Instance of an inventory UI slot node which will hold an item.  
  * Inventory\_ui\_slot: This is the scene that will hold a given item.  
    * Sprite2D: This will hold the background sprite for the item slot.  
    * Container: This will be the parent node for Panel and Sprite2D.   
    * Panel: This will hold the information about the current item in the slot.  
    * Sprite2D: This will hold the sprite of the item itself.

* **Main Menu UI:** The main menu UI will be a control node with sub control nodes, rich text labels, and texture buttons. The texture buttons will be used to quit the game, open the settings menu, start a new game, load a game, or play multiplayer. The rich text labels are used to give each button a label corresponding to their function. The UI will fall under the “GameComponents” class, which sends data back to the game manager, such as whether to initialize a new game or to save setting changes. 	

* **In-game UI:** The in-game UI will be made of a couple different sub-UI’s including an inventory screen, pause menus, and a map. The map will receive player data from the game manager in order to highlight where the player is. The pause menu will interact with the “Pausable” class to toggle what’s paused on menu open or close. Lastly, the inventory will receive and send data to the game manager as it’ll be listed as a “GameComponent” all of these menus will be control nodes with respective texture buttons, rich ui labels, and texture rectangles. 

* **Settings Menu:** The settings UI will also be a control node with sub control nodes, buttons, rich text labels and sliders. The rich text labels are used to give each button, slider, and dropdown a label corresponding to their function. Once again, this portion of the UI will be under the “GameComponents” class, as it’ll send settings data back to the game manager to save. 

* **Online Multiplayer Menu:**  
  * Join Game: Use NetworkedMultiplayerENet to handle multiplayer functionality. Create a button in the UI (via Button node) to allow players to join an existing game session.  
  * Create Game: Implement a lobby system by creating a custom scene that allows the player to configure and host a game. Use the NetworkedMultiplayerENet for server-client communication.  
  * Matchmaking: Implement automatic matchmaking using Godot's MultiplayerAPI and NetworkedMultiplayerENet to match players based on certain criteria.  
  * Disconnect: A button in the multiplayer menu can call the get\_tree().network\_peer \= null to disconnect from the server and return the player to the main menu.

* **Dam Building Minigame**:   
  * Materials: Create interactive materials using StaticBody2D and CollisionShape2D. Custom properties to each material type (e.g., wood, stone, etc.), and use Area2D or CollisionShape2D to detect collisions with the environment or other objects.  
  * Water Flow: Simulate water flow with a simple physics-based approach. Particles2D for water effects or manually move water using Tween or physics-based forces.  
  * Time Challenge: Implements a countdown timer using a Timer node. When the time runs out, trigger a failure condition or end the game.  
      
* **Swimming Minigame:**   
  * Being underwater will require a linear 2D scene to set the playable minigame area with 2D Area. 2D Collision Shapes to detect hits between the Player, Objects, and NPC’s.   
  * Animated sprites for the Player Object and NPC’s for dynamic movement.  
  * Water movement can be simulated similarly to the Dam Building Minigame with Particles2D, Tween, and physics-based forces  
  * Music and collisions between the Player Object and Interactable Objects/NPC’s will be handled by AudioStream2D-BackgroundMusic, AudioStream2D-SFX, and AudioStreamPlayer2D respectively. AudioStream2D-SFX and AudioStreamPlayer2D will ensure the correct sound is played on collision.  
* **Tree Cutting Minigame:**   
  * Materials: Area2D and CollisionShape2D will be used for the cursor and the tree, detecting when the cursor is in a correct position to bite/cut into the tree.  
  * Chopping the Tree: InputEventMouseButton can be used to detect mouse clicking in Godot. Particles2D may be used to simulate wood chips when the player makes a bite/cut into the tree.  
  * Tree State: AnimationPlayer can be used to animate the state of the tree as the player continues to bite/cut into the tree.  
* **Communication Minigame:**   
  * Will use a 2D background and a Player Object and its animated sprites and Audiostream. There will be a defined number of animated poses and each animation will have a corresponding button displayed over it e.g. up, down, left, right. The positions will be randomly assigned and stored in CommunicationSequence\_1 that the player will watch and then attempt to replicate. Correct replication of the sequence will result in a success and moving on to CommunicationSequence2-3 while failure of sequence will result in replication of the current sequence and 2nd failure will exit the minigame.


* **Canal Puzzle/Minigame:**   
  * Tilemap2D: This will be a grid system used to define the minigame area.  A grid system will make the randomization of levels possible.    
  * Interactable Object: These will be rocks, and other immovable physics objects which will stop the water flow. It will also include a physics for a  goal location so that the game will be able to detect if the water hits the goal.    
  * Particles2D: This will be used to simulate water flow from the source.  
  * AudioStream2D-BackgroundMusic: This will be responsible for playing the minigame’s music.  
  * AudioStream2D-SFX: This will be responsible for playing the game’s SFX.   
* **Feedback UI**:   
  * Text Input Field: A LineEdit node where the player can type their feedback.  
  * Feedback Type Dropdown: A PopupMenu for selecting the type of feedback (e.g., Bug Report, Feature Request).  
  * Submit Button: A Button that the player can click to submit their feedback.  
  * Confirmation Message: A Label or Popup to confirm that the feedback was submitted successfully.  
  * Error Handling: A message or Popup to inform the player if their feedback couldn't be submitted (e.g., no internet connection).

## **Section 3: Coding Guideline**

[https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript\_styleguide.html](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_styleguide.html)

We will be using the GDScript styleguide produced and maintained by the Godot Project. Considering that this project is designed in Godot using GDscript we thought it would be best to follow the style guide created by the language/software we are using. The people who created the guide would most likely be the most knowledgeable, as they work consistently with Godot and GDscript. 

## **Section 4: Team Process Description**

### Software Tool Set Justification: 

Godot: Godot will be the primary tool used for our game development. Godot is a fantastic tool for game development as it’s open-source, routinely updated, and has a wide community of support. The built in IDE makes it easy for our programmers to work on the project. Godot is not resource intensive which means it’s compatible with all of our machines. It also supports cross-platform development so that we can work with windows and apple computers. Lastly Godot is distributed under the MIT license which allows us to produce games and distribute them as long as we attribute Godot as the engine. 

Github: We will be using Github for our version control system. We are choosing it not only because it’s a requirement for class but also because it has great integration with Godot. Godot has built in version control with Git, and thus it was easy to set up our repository with very few extra steps. 

Discord: Discord is an accessible communication program because creating an account and server is free.  It is effective at splitting topics into various text channels, which will help us differentiate between important aspects of our team work.  

FL Studio: This is a Digital Audio Workstation that all music and sound design for the game will be conducted in.  Grant already has a full license for this software and several years of experience using it, so it makes sense to take advantage of the resource.  Furthermore, FL Studio has a free, unlimited trial version that is accessible to other group members if they need to access it.  

Pixilart: Pixilart is an online drawing editor that will be used to make the visual content for our game. It is free to use and accessible through any web browser, and has complimentary apps on Google Play and the App Store for both iOS and Android. It is a robust and in-depth editor that allows our group to create objects, backdrops, and sprites that make up the visual medium of our game. Being free and accessible to all group members makes it a good tool for our visual design. 

### Roles Justification: 

**Grant** is the Sound Designer and Data flow manager, which are two different and important roles. Having a data flow manager will help everyone in the project better understand the whole system, and design and develop accordingly. Grant is suited to this role because he has experience from Software engineering 1, as well as with Canva, which is the tool he will use to model the data.  
He is also the Sound Designer, which brings the actions of the game together, and overall improves the experience of the player. Without engaging the player with sound, they may get bored and leave the game without learning about beavers or enjoying the game. Grant is suited for this role because he has experience in sound design and already owns licenses and has experience with a variety of sound design tools. 

**Grant’s** Schedule:

* Week 3 1/24: Record and add at least 5 sound assets to the GitHub repository.  Also, create the initial data flow chart based on the current game status. Complete Track-1 (for the menu music).    
* Week 4 1/31: Add another 5 sound assets to the repository.  Complete Track-2 (forest area)  
* Week 5 2/7: Fully implement a method that switches music tracks when a new area reached by the player.  
* Week 6 2/14: Fully implement a method that plays sound effects on contact with map objects.   
* Week 7 2/21: Incorporate all sound effects into the appropriate hit-box method and incorporate all musical tracks into the corresponding map areas.   
* Week 8 2/28: Create a Google sheet and a corresponding Google form to collect playtest feedback.    
* Week 9 3/7: Update data flow documentation now that most methods should be clearly established.   
* Week 10 3/14: Finalize and publish data flow documentation to the GitHub repository. 

**Jacob** is the lead artist, which is essential to the playability of the game. Without art, virtually nobody would play the game, and it would meet none of its use case scenarios. Jacob is suited to this role because he has creative inspiration regarding the subject of the game, an interest in pixel art, and a willingness to learn these new skills for the sake of the project. 

**Jacob’s** Schedule 

* Week 3 1/24: Generate first character sprite concept and potentially primary design. Make a List of major in-game items/scenes that will need to be generated. Begin and set up the basic structure of the game map. Create placeholder assets, items, and UI to allow functionality testing.  
* Week 4 1/31: Finalize character design and create 1st half of known assets and game items including NPC’s. Refine game map. Set up a test area to allow work on character interaction and times.  
* Week 5 2/7: Work on text box style/display allowing for text use and implementation into game. Adjust the game map to further reflect any design choices made or changed on it. Create 2nd half of in game assets, items, and NPC’s.  
* Week 6 2/14: Finish all previous work and add detail and design to make products more visually polished. Adjust the game map to reflect changes and feedback. Create basic structure for first half of minigames  
* Week 7 2/21: Advance final design for half of the environment and levels for mini-games. Begin base design for 2nd half of environments/ minigames.  
* Week 8 2/28 : Adjust any details of environments/levels for all mini-games. Advance to final design of 2nd half of environments/ minigames  
* Week 9 3/7: Finalize design of environments and add additional assets based on work requirements. Begin final artistic details and requirements to make the game more aesthetically pleasing.  
* Week 10 3/14: Finish final artistic details and requirements to make the game more aesthetically polished.

**Guillermo** is the Network Designer, which will handle the process of making the game multiplayer capable. Without a dedicated Network Designer, the process of making the game multiplayer would be restricted to multiple users on the same device, which would vastly limit the use cases of our game. Additionally, the role has the responsibility of making any single player code function in multiplayer, which allows the other members of the team more time to develop the core features of the game. Guillermo is a good fit for this role because he has interest in learning network processes, and he has shown the willingness and ability to learn this over the quarter. 

**Guillermo’s** Schedule 

* Week 3 1/24: Set up a basic server-client connection prototype using Godot. Create a multiplayer-specific branch on GitHub.  
* Week 4 1/31: Synchronize player movement between server and clients. Test and refine movement synchronization to ensure smooth player control.  
* Week 5 2/7: Fully implement basic multiplayer interactions (e.g., players can tag or interact with each other).  
* Week 6 2/14: Implement and test methods to synchronize sound effects for multiplayer actions. Add functionality to handle player disconnection gracefully.  
* Week 7 2/21: Introduce NPCs with basic behavior synchronized across all clients. Ensure NPC reactions to players are consistent across the network.  
* Week 8 2/28: Finalize multiplayer gameplay mechanics, ensuring all features (movement, interactions, NPCs) are functioning smoothly conduct playtesting with a small group to identify bugs and gather feedback.  
* Week 9 3/7: Perform integration tests for all multiplayer features to ensure they work together seamlessly. Update documentation to reflect the finalized multiplayer implementation.  
* Week 10 3/14: Finalize and polish all multiplayer features. Publish updated documentation to GitHub and prepare the multiplayer feature for the game’s release.

**Mike** is the Head developer, which is necessary to organize the other developers and make sure game development continues smoothly throughout the quarter. He will be the most involved in the building blocks of our code, which will allow the less experienced developers an ability to contribute and work on the project. Mike is suited for this role because he has previous experience working with game development, and specifically the tools and scripting language we will be using for the project. 

**Mike’s** Schedule 

* Week 3 1/24: Finish the player instance, the controls, and basic movement. Finish sketch of menu and in game UI. Finish setting up the resource file system, so fellow developers know where to place and organize files in the Godot section.  
* Week 4 1/31: Finish game start menu UI and functionality, also finish basic save/load/quit system that stores player location and minor progress markers  
* Week 5 2/7: Finish scene management implementation including connections to game system objects and all related components necessary to complete functionality. Also finish basic NPC navigational and interact system.   
* Week 6 2/14: Finish inventory basics, main game UI.  
* Week 7 2/21: Half of the total number of minigames are now finished.  
* Week 8 2/28: All primary requirements for the game system objects are complete, including proper system loading and saving, minigames and NPC interaction, inventory, and any other large overarching game mechanics. All minigames should be finished and complete at this point.   
* Week 9 3/7: Testing phase in which I’ll be collaborating with different portions of the team to repair bugs and issues identified during testing connecting to the main game system and individual components. We are also checking the executables at this point to ensure the game runs after being built. All developed tests will PASS at this point.  
* Week 10 3/14: Game development now moves towards post-production where I finish an Itch.io landing page, ensuring the executable is working and running on multiple machines. We also finish any promotional or documentation materials at this point. 

**Ryan** is the lead content researcher. This role is required as it is responsible for the facts and information about beavers which will inform players as they play the game. As this is one of the main purposes of the game, and vastly expands its usage scenarios, it is important that a lead researcher be present. Ryan is suitable for this role because he has done previous research projects at OSU and is willing to do the work required to learn and inform about beavers and the environment which surrounds them. 

**Ryan’s** Schedule 

* Week 3 1/24: Compile a document about beavers containing at least 3 distinct sources. Work with the rest of the team to use this information to develop the main storyline and activities of the game.   
* Week 4 1/31:  Develop at least 5 passive ways and at least 5 active ways users can see information during gameplay. Design at least 5 tests for the basic player instance and the save/load functionality.  
* Week 5 2/7: Create at least 25 potential dialogue options that inform about beavers that will go in the game. Carry out the tests developed in the previous week.  
* Week 6 2/14: Design at least 10 tests based on the User Scenarios to conduct on the game.   
* Week 7 2/21: Conduct any relevant tests (from the previous week) on the current part of the game. Identify at least 3 places in the gameplay where more information (passive or active) about beavers can be included.  
* Week 8 2/28:  Research ways to link players to external resources about beavers.   
* Week 9 3/7: Design tests based on user feedback to apply to the game.   
* Week 10 3/14: Design tests for cross-platform compatibility issues. 

**Mia** is the lead environment designer, which is important in creating a cohesive and solid gameplay environment. The environment, combined with the music, will provide the correct mood for the player, making the game more enjoyable as they play. Additionally, it will help to spark interest to dig deeper into the information about beavers. Mia is a good fit for the lead environment designer because she is interested in learning more about level and map design. Mia has shown that she will spend the time required to learn about these topics, and will be able to implement them by the end of the term. 

**Mia’s** Schedule 

* Week 3 1/24: Finish collecting research from 5 credible sources on beaver habitats / environmental surroundings. Complete a general sketch of the game map.  
* Week 4 1/31: Finish sketches of mini-game environments.   
* Week 5 2/7: Finish implementing game map.   
* Week 6 2/14: Make any revisions or changes to game map based on group feedback.   
* Week 7 2/21: Finish the environments / levels for half of the mini-games.  
* Week 8 2/28: Finish the environments / levels for the all the mini-games.   
* Week 9 3/7: Make changes to the environments based on collected feedback from team members and users.   
* Week 10 3/14: Finalize all details for the game. Finish any documentation needed for the game.

## 

## 

## 

## 

## 

## 

## 

## 

### Risks: 

* Many of our team members are new to using Godot, so we will need to take the time to learn the software.  If we are unable to quickly adjust to the new software, it could leave us without enough time to finish the project.   
* The networking portion of multiplayer implementation is a serious challenge.  If it's an unattainable challenge, the rest of the team will need to adjust.  
* Certain features that we expect to work may not be possible due to software limitations.  We may either need to cull those features, or develop alternative solutions.  This could use more resources and time than we can afford. 


### External Feedback:

*  We believe that external feedback would be most helpful around Week 8 assuming that we have a stable build.  As soon as a stable build is accessible, we will ask for feedback from play testers.  
* The feedback will be acquired using a Google form that the testers will fill out after playing through the game. This should give us time to make adjustments before the final release of the game. 

### Timeline:

* Week 3 1/24: All planning should be completed, and game development should begin.    
* Week 4 1/31: Finalize major story elements ideation and map design.   
* Week 5 2/7: Finish map implementation, finish base NPC instances (movement, interaction, basic memory system).   
* Week 6 2/14: Finish writing and implementation of NPC Dialogue and flavor text.   
* Week 7 2/21: Multiplayer elements should be fully incorporated. Finish half of all designed minigames. (For example, if we designed 6 minigames by week 3, 3 minigames should be playable at this point).   
* Week 8 2/28: Complete a stable release to use for user feedback.  Collect user feedback data to later improve the game.   
* Week 9 3/7: Utilize the user feedback information to make adjustments to the game as needed.   
* Week 10 3/14: Complete finishing touches, and upload the game to a publicly accessible place like itch.io.  

## 

### Risk Assessment:

* The data and data-parsing isn’t standardized among different parts of the project  
  * Medium  
  * Medium  
  * We are working on many different parts of the code asynchronously, which allows us to work faster but may cause us to implement the data storage and parsing multiple different ways.This means the likelihood if it occurring is moderate, and the impact is based on Mike’s experience in other games, where it could crash the game.   
  * To reduce the likelihood of this occurring, we have made a guide on how to implement things like data storage and data-parsing, which when followed will standardize how we interact with data. We can review each other's code regularly in order to verify our data interactions are consistent.  
  * By creating a piece of data with one data storage mechanism, we can give it to each data-interacting piece in the project to see if it works the same way. This will show if it parses the same way, which will also imply it creates it the same way.   
  * We would have to remove the way one person implemented data interacting, and completely replace it with another. We would default to using Mike’s methods, as he is the head dev.   
* The multiplayer implementation will not be functional by at least week 8    
  * Low  
  * Low  
  * Guillermo has been making consistent progress with updates about networking, and is confident that he will be able to create a networking system. He has produced demos of socketing and other pieces of making the networking work.   
  * To reduce the impact, we are designing the minigames with single player in mind first, and then adapting that to work with multiplayer. This means that even if the networking is never fully implemented, the game will still function well. We are checking and getting updates from Guillermo on the networking progress to reevaluate the likelihood on a regular basis.   
  * We can test the multiplayer sending data from 2 different machines via LAN or online depending on how Guillermo implements it  
  * Should the multiplayer implementation not be functional by week 8, we will abandon the multiplayer solution and focus on fixing any holes the lack of multiplayer may have left in the system.   
* Other users may have different operating systems than what we have designed on, which could cause new bugs  
  * Low  
  * Medium  
  * Godot has built-in implementation in order to make the software run the same on multiple different platforms, which means bugs on different operating systems would be unlikely.   
  * Our first step towards mitigating this problem was our choice in the development framework being Godot. This will do most of the heavy lifting for us, of allowing it to run on multiple platforms. To get a better estimate on how likely and impactful this may be, we can do research on other OS specific bugs in other Godot built games.   
  * We can develop a testing suite for game functionality, which we can run on many different operating systems in order to see if the game behaves the same way. We will also get user feedback on the game, which will give us insight into any bugs that we don’t know about.   
  * We will test for bugs on other operating systems after our stable release (week 8), so we will have the next 2 weeks to patch the bugs that we may not have seen before then.   
* We will be unable to finish the game on schedule due to insufficient experience with the game engine.   
  * Medium  
  * High  
  * We are basing this estimate on how our schedules have come along and how well we have been on time with our demos. The impact was estimated because the risk is not finishing the project, which would be a very bad situation.   
  * We are updating our schedules and communicating with the other members of the group in order to make sure each member is on task and doing their share to reduce the likelihood. This communication also lets us estimate how the project is coming along and if we need to change the pace in which we are working.   
  * We will keep track of when somebody falls behind schedule, which will notify us that they may need to do extra work or have extra help in their section.   
  * If somebody is really struggling with Godot and unable to do the work allocated to them, we will attempt to shrink the scope of the project in order to get a finished product out on time  
* Miscommunication among team members could lead to different members creating different things, and it comes out as a mismatch at the end.  
  * Low likelihood of occurring  
  * Medium impact if it occurs   
  * We are basing this estimate on our current communication of our progress and weekly goals.   
  * Sharing our weekly updates, prevents group members from clashing on design aspects. We also have a color palette and style guide to ensure all members are on the same page. These weekly updates also help to evaluate how close our perceptions of each part of the project are.   
  * Regular showcases of designs and implementation throughout the process, so each other member will immediately know their ideas match. This will identify the problems earlier than just comparing final drafts.  
  * There will be a meeting between all impacted members, where they work out the details on exactly what they are making. This would slow the project, and may require cutting some smaller features. 

We added 2 risks (the first and the third), in addition to streamlining the other risks to be more clear with what the risks were. 

### **Project Schedule:** 

| Milestones: | Tasks: |
| :---- | :---- |
| Traversable Map Done by Week 6 at the latest | Create and sketch map outline accurate to beaver environments To be completed within a week (Week 4\) Create pixel art tile assets To be completed within two weeks (Week 5\) Use the tile assets to populate the map in Godot To be completed within a week (Week 6\) Define boundaries and implement collision detection in Godot To be completed within a week (Week 6\) Implement player movement using keyboard in Godot To be completed within a week (Week 4\) |
| NPC and Object Implementation Done by Week 7 at the latest  | Decide what objects and NPCs will be included and their purpose To be completed within a week (Week 5\) Create pixel art objects and NPC sprites  To be completed within two weeks (Week 5 & 6\) Write NPC dialogue To be completed within a week (Week 6\) Add objects and NPCs to the map and implement collision detection in Godot To be completed within a week (Week 7\) |
| Minigame Implementation Done by Week 8 | Finalize minigame ideas and details (rules, objectives, mechanics, rewards, etc.) To be completed within a week (Week 5\) Create visual assets for the minigames To be completed within two weeks (Weeks 6 & 7\) Design UI for each minigame  To be completed within a week (Week 7\) Code the core gameplay logic in Godot To be completed within three weeks (Weeks 6, 7 & 8\) Implement game state management (start, pause, exit) To be completed within a week (Week 8\) Integrate the minigames into the game map To be completed within a week (Week 8\) |
| Multiplayer Implementation Done by Week 8 | Finalize story details for a multiplayer mode To be completed within a week (Week 5\) Set up networking infrastructure for multiplayer mode To be completed within three to four weeks Design UI for multiplayer mode |
| Stable Release  Done by Week 8 | Finalize minigames and multiplayer implementation To be completed by Week 8 Design tests to perform on the game To be completed within two weeks (Week 7 & 8\) Create a feedback form To be completed within a week (Week 8\) |

### Team Structure: 

**Grant**:  
Grant is the Sound Designer, which means he handles creating and implementing sounds into the game. This includes the overall game music, creating sound effects for the player and their interactions, adding sound control (such as volume sliders) and creating sound objects to link player actions to their sound effects.   
He is also the data flow manager, which means he will model the structure of our project so we are able to better understand it. 

**Mike**:  
Mike is the Head Developer, which means he is in charge of setting up the game to a point where other less experienced members are able to code and add to it. Additionally, he directs the programming workload on the other members of the group, and provides help when needed. 

**Guillermo:**  
Guillermo is the lead multiplayer programmer and researcher, which is his job to learn how to implement multiplayer into our game. This includes setting up the systems required in order to have a multiplayer game work, and the features that should be changed or added when making a multiplayer experience. 

**Jacob**:  
Jacob is the lead artist, which means he will direct other people when making art assets, and will produce the majority of art assets for the game. It is also his responsibility to add these assets into the game and make sure they look and move how he planned it. 

**Mia**:  
Mia is the level and environment designer, which means she will incorporate our ideas for the game and our information about beavers to design the layout of the map and the art of the level pieces. This includes making mockups of potential areas, pixel art for background objects, and how the levels should be traversed in the game. 

**Ryan**:  
Ryan is the head researcher, which means he is in charge of researching beavers and incorporating that research into the game. This includes creating dialogue, advising about environmental details, advising about specific art objects and creating game features which highlights the research. 

### **Test Plan & Bugs**

**Specific Aspects to Test**  
Game mechanics are at the core of the game’s experience. We will test features such as player movement, inventory management, NPC interactions, and mini-games. These elements form the backbone of the game and are essential for ensuring that the gameplay functions as intended. For educational content, we will verify that the beaver-related facts are accurate.

UI testing will be another aspect. We will ensure that the user interface is intuitive and easy to navigate, with clear menus, buttons, and transitions between screens. We will check that all visual elements, such as text, icons, and images, are displayed correctly, and that the game’s menus and controls are responsive and functional.

We will also test sound and music. It is important to verify that sound effects and music play correctly at appropriate times during gameplay. This includes ensuring that the audio cues function during the player’s experience, such as environmental sounds, interactions, or background music.

Additionally, we will test the save/load system to make sure that players’ progress is preserved. This includes verifying that when a player saves and exits the game, their location, inventory, and other game data persist when the game is loaded again.

Finally, the multiplayer aspect will be another focus. We will test the synchronization of player actions across different devices to ensure that movements and interactions are consistently reflected in real-time. This will include verifying that server-client communication is functioning correctly, and that the game experience remains smooth for all players involved.

**Test Strategy**  
To test these aspects, we will follow a structured process. First, we will create a test plan using Trello. This will help us organize and keep track of what needs to be tested. We will break testing into smaller, manageable tasks, such as testing player movement or NPC dialogue one at a time to ensure each part works as expected.

For unit testing, we will test each part of the game separately manually and, if time allows, with test automation scripts to make testing faster and more reliable. For example, we’ll check if the player moves correctly when pressing keys like WASD. We’ll also test the inventory system to make sure items can be added, removed, and shown properly. We’ll check NPC interactions to ensure that dialogue boxes appear when talking to NPCs and that the content is displayed correctly

Once these parts pass their individual tests, we’ll do system testing to make sure everything works well together. For example, we’ll test the save/load system to make sure player progress, like inventory and location, is saved properly. We’ll also test multiplayer to make sure players’ movements and actions match up on different devices. Additionally, we’ll test the menus and how the game moves between different screens to ensure smooth transitions.

For usability testing, we’ll have real users try the game to see if it’s easy to understand and navigate. We’ll get feedback on how simple it is to learn the controls, move through menus, and enjoy the educational content. We’ll also test features like resizing text and high-contrast text to make sure the game is accessible to everyone. We’ll watch how players interact with the educational content to see if they’re learning and if the game encourages them to keep playing.

Finally, we will share test results through Discord and track any bugs we find on GitHub Issues. We’ll categorize each bug (like UI problems, multiplayer issues, or sound bugs) and describe how to reproduce it. We’ll also use Trello to assign tasks and prioritize fixing bugs or making improvements based on the results of our tests. By following this process, we’ll make sure the game works well and is fun and educational for players.

### **Documentation Plan** 

* Installation guide:  
  * What: This is a comprehensive guide which will teach users how to create a build of the game on their own machine.  While the game will be posted on a website (itch.io), this guide will provide an additional option to access the game.    
  * Who: There will be different installation guides for different operating systems, so team members will be responsible for ensuring that there is a guide for their own operating system.    
  * When: This guide will be created after the post-playtest adjustments have been made.  
  * Why: This guide will improve the accessibility of the game.  It will be accessible to those who are able to get a copy of the game, but may not necessarily have access to a stable internet connection.    
* Help Menu UI:  
  * What: This is a written in-game guide to the game’s controls, user interface, and multiplayer options.  It will be a tab of the menu and accessible to the user upon pausing the game.   
  * Who: Mike will be responsible for the creation of the help menu.  
  * When: A version of this menu should be complete before the playtest (week 8).   
  * Why: The help menu will ensure that all users will be able to access information about how to play the game.  The users are not forced to look at the help menu, but it is easy to find the resource if they want it.  Such a menu will be helpful for users in case they forget how to operate the game.    
* Data Flow Documentation:  
  * What: A visual representation of the communication between different scenes, instances, nodes, and other software elements.  It should display the communication patterns between different function.  
  * Who: Grant is responsible for creating this documentation.  
  * When: This will be created in parallel with the development of the software.  
  * Why: It will help future developers, potential mod developers, and users interested in the game development process learn more about the structure of the game.  Furthermore, it will aid in the debugging process.  If the software engineer responsible for fixing the bug is unfamiliar with the structure of the program, they will be able to get an idea of what the bug could be connected to.  